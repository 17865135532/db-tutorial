---
title: 数据库系统概论
date: 2018/06/25
categories:
- database
tags:
- database
---

# 数据库系统概论

> 本文所述内容主要针对的是关系型数据库，nosql 数据库并不适用。

<!-- TOC depthFrom:2 depthTo:3 -->

- [1. 索引](#1-索引)
    - [1.1. 索引的优点和缺点](#11-索引的优点和缺点)
    - [1.2. 索引类型](#12-索引类型)
    - [1.3. 索引数据结构](#13-索引数据结构)
    - [1.4. 索引原则](#14-索引原则)
- [2. 事务](#2-事务)
    - [2.1. ACID](#21-acid)
    - [2.2. 并发一致性问题](#22-并发一致性问题)
    - [2.3. 事务隔离级别](#23-事务隔离级别)
- [3. 数据库锁](#3-数据库锁)
    - [3.1. 数据库锁的粒度](#31-数据库锁的粒度)
    - [3.2. 数据库锁的类型](#32-数据库锁的类型)
    - [3.3. 数据库锁的协议](#33-数据库锁的协议)
- [4. 多版本并发控制](#4-多版本并发控制)
    - [4.1. 版本号](#41-版本号)
    - [4.2. Undo 日志](#42-undo-日志)
    - [4.3. 实现过程](#43-实现过程)
    - [4.4. 快照读与当前读](#44-快照读与当前读)
- [5. 分库分表](#5-分库分表)
    - [5.1. 水平拆分](#51-水平拆分)
    - [5.2. 垂直拆分](#52-垂直拆分)
    - [5.3. Sharding 策略](#53-sharding-策略)
    - [5.4. Sharding 存在的问题及解决方案](#54-sharding-存在的问题及解决方案)
- [6. 关系数据库设计理论](#6-关系数据库设计理论)
    - [6.1. 函数依赖](#61-函数依赖)
    - [6.2. 异常](#62-异常)
    - [6.3. 范式](#63-范式)
- [7. ER 图](#7-er-图)
    - [7.1. 实体的三种联系](#71-实体的三种联系)
    - [7.2. 表示出现多次的关系](#72-表示出现多次的关系)
    - [7.3. 联系的多向性](#73-联系的多向性)
    - [7.4. 表示子类](#74-表示子类)
- [8. 资料](#8-资料)

<!-- /TOC -->

## 1. 索引

索引能够轻易将查询性能提升几个数量级。

- 数据量小的表，使用全表扫描比建立索引更高效。
- 数据量大的表，使用索引更高效。
- 数据量特大的表，建立和维护索引的代价将会随之增长，可以使用分区技术。

### 1.1. 索引的优点和缺点

优点：

- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
- 大大减少了服务器需要扫描的数据行数，从而提高检索速度。
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

缺点：

- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
- 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立组合索引那么需要的空间就会更大。
- 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

### 1.2. 索引类型

主流的关系型数据库一般都支持以下索引类型：

- 普通索引：最基本的索引，没有任何限制。
- 唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
- 主键索引：一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。
- 组合索引：多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。

### 1.3. 索引数据结构

**主流数据库的索引一般使用的数据结构为：B-Tree 或 B+Tree。**

#### B-Tree

B-Tree 不同于 Binary Tree（二叉树，最多有两个子树），它是平衡搜索树。

一棵 M 阶的 B-Tree 满足以下条件：

- 每个结点至多有 M 个孩子；
- 除根结点和叶结点外，其它每个结点至少有 M/2 个孩子；
- 根结点至少有两个孩子（除非该树仅包含一个结点）；
- 所有叶结点在同一层，叶结点不包含任何关键字信息；
- 有 K 个关键字的非叶结点恰好包含 K+1 个孩子；

对于任意结点，其内部的关键字 Key 是升序排列的。每个节点中都包含了 data。

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/Database/master/images/database/B-TREE.png" />
</div>

对于每个结点，主要包含一个关键字数组 Key[]，一个指针数组（指向儿子）Son[]。

在 B-Tree 内，查找的流程是：

1.  使用顺序查找（数组长度较短时）或折半查找方法查找 Key[]数组，若找到关键字 K，则返回该结点的地址及 K 在 Key[]中的位置；
2.  否则，可确定 K 在某个 Key[i]和 Key[i+1]之间，则从 Son[i]所指的子结点继续查找，直到在某结点中查找成功；
3.  或直至找到叶结点且叶结点中的查找仍不成功时，查找过程失败。

#### B+Tree

B+Tree 是 B-Tree 的变种：

- 每个节点的指针上限为 2d 而不是 2d+1（d 为节点的出度）。
- 非叶子节点不存储 data，只存储 key；叶子节点不存储指针。

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/Database/master/images/database/B+TREE.png" />
</div>

由于并不是所有节点都具有相同的域，因此 B+Tree 中叶节点和内节点一般大小不同。这点与 B-Tree 不同，虽然 B-Tree 中不同节点存放的 key 和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中 B-Tree 往往对每个节点申请同等大小的空间。

##### 带有顺序访问指针的 B+Tree

一般在数据库系统或文件系统中使用的 B+Tree 结构都在经典 B+Tree 的基础上进行了优化，增加了顺序访问指针。

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/Database/master/images/database/带有顺序访问指针的B+Tree.png" />
</div>

在 B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B+Tree。

这个优化的目的是为了提高区间访问的性能，例如上图中如果要查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

### 1.4. 索引原则

#### 最左前缀匹配原则

mysql 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配。

例如：`a = 1 and b = 2 and c > 3 and d = 4`，如果建立（a,b,c,d）顺序的索引，d 是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整。

#### = 和 in 可以乱序

比如 a = 1 and b = 2 and c = 3 建立（a,b,c）索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。

#### 尽量选择区分度高的列作为索引

让选择性最强的索引列放在前面，索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。

示字段不重复比例公式： `count(distinct col) / count(*)`

#### 索引列不能参与计算

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

例如下面的查询不能使用 actor_id 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

#### 尽量的扩展索引，不要新建索引

比如表中已经有 a 的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

#### 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```
SELECT film_id, actor_ id FROM sakila.film_actor
WhERE actor_id = 1 AND film_id = 1;
```

#### 前缀索引

对于文本类型的列，必须使用前缀索引，只索引开始的部分字符。

对于前缀长度的选取需要根据索引选择性来确定。

#### 覆盖索引

索引包含所有需要查询的字段的值。

具有以下优点：

- 因为索引条目通常远小于数据行的大小，所以若只读取索引，能大大减少数据访问量。
- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

## 2. 事务

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/database/master/images/database/数据库事务.png"/>
</div>

事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

- MySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。
- Oracle 默认采用非自动提交模式。也就是说，必须通过 COMMIT 来提交事务。

### 2.1. ACID

#### 原子性（Automicity）

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

#### 一致性（Consistency）

数据库在事务执行前后都保持一致性状态。

在一致性状态下，所有事务对一个数据的读取结果都是相同的。

#### 隔离性（Isolation）

一个事务所做的修改在最终提交以前，对其它事务是不可见的。

#### 持久性（Durability）

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。

---

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时要只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对数据库奔溃的情况。

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/database/master/images/database/数据库ACID.png"/>
</div>

### 2.2. 并发一致性问题

在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

#### 丢失修改

T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/database/master/images/database/数据库并发一致性-丢失修改.png"/>
</div>

#### 脏数据

T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/database/master/images/database/数据库并发一致性-脏数据.png"/>
</div>

#### 不可重复读

T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/database/master/images/database/数据库并发一致性-不可重复读.png"/>
</div>

#### 幻影读

T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/database/master/images/database/数据库并发一致性-幻读.png"/>
</div>

#### 并发一致性解决方案

产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。

并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

### 2.3. 事务隔离级别

未提交读（READ UNCOMMITTED） - 事务中的修改，即使没有提交，对其它事务也是可见的。
提交读（READ COMMITTED） - 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
可重复读（REPEATABLE READ） - 保证在同一个事务中多次读取同样数据的结果是一样的。
可串行化（SERIALIXABLE） - 强制事务串行执行。

| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |
| :------: | :--: | :--------: | :----: |
| 未提交读 | YES  |    YES     |  YES   |
|  提交读  |  NO  |    YES     |  YES   |
| 可重复读 |  NO  |     NO     |  YES   |
| 可串行化 |  NO  |     NO     |   NO   |

## 3. 数据库锁

### 3.1. 数据库锁的粒度

- **表级锁** - 直接锁定整张表，在锁定期间，其它进程无法对该表进行写操作。如果是写锁，则其它进程则读也不允许。
- **行级锁** - 仅对指定的行记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。

主流数据库对锁粒度的支持：

- Mysql 的 InnoDB 存储引擎支持表级锁和行级锁；MyISAM 存储引擎只支持表级锁。
- Oracle 支持表级锁和行级锁。

### 3.2. 数据库锁的类型

#### 读写锁

- 排它锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

有以下两个规定：

- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

锁的兼容关系如下：

|  -  |  X  |  S  |
| :-: | :-: | :-: |
|  X  | NO  | NO  |
|  S  | NO  | YES |

#### 意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

各种锁的兼容关系如下：

|  -  |  X  | IX  |  S  | IS  |
| :-: | :-: | :-: | :-: | :-: |
|  X  | NO  | NO  | NO  | NO  |
| IX  | NO  | YES | NO  | YES |
|  S  | NO  | NO  | YES | YES |
| IS  | NO  | YES | YES | YES |

解释如下：

- 任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；
- S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。

### 3.3. 数据库锁的协议

#### 三级锁协议

**一级锁协议**

事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

| T<sub>1</sub> | T<sub>2</sub> |
| :-----------: | :-----------: |
|   lock-x(A)   |               |
|   read A=20   |               |
|               |   lock-x(A)   |
|               |     wait      |
|  write A=19   |       .       |
|    commit     |       .       |
|  unlock-x(A)  |       .       |
|               |    obtain     |
|               |   read A=19   |
|               |  write A=21   |
|               |    commit     |
|               |  unlock-x(A)  |

**二级锁协议**

在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。

可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

| T<sub>1</sub> | T<sub>2</sub> |
| :-----------: | :-----------: |
|   lock-x(A)   |               |
|   read A=20   |               |
|  write A=19   |               |
|               |   lock-s(A)   |
|               |     wait      |
|   rollback    |       .       |
|     A=20      |       .       |
|  unlock-x(A)  |       .       |
|               |    obtain     |
|               |   read A=20   |
|               |    commit     |
|               |  unlock-s(A)  |

**三级锁协议**

在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。

可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

| T<sub>1</sub> | T<sub>2</sub> |
| :-----------: | :-----------: |
|   lock-s(A)   |               |
|   read A=20   |               |
|               |   lock-x(A)   |
|               |     wait      |
|   read A=20   |       .       |
|    commit     |       .       |
|  unlock-s(A)  |       .       |
|               |    obtain     |
|               |   read A=20   |
|               |  write A=19   |
|               |    commit     |
|               |  unlock-X(A)  |

#### 两段锁协议

加锁和解锁分为两个阶段进行。

可串行化调度是指：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。

事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。

```html
lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
```

但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。

```html
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
```

## 4. 多版本并发控制

多版本并发控制（Multi-Version Concurrency Control, MVCC）是实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC；可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

### 4.1. 版本号

- 系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号：事务开始时的系统版本号。

MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：

- 创建版本号：指示创建一个数据行的快照时的系统版本号；
- 删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。

### 4.2. Undo 日志

MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。

### 4.3. 实现过程

以下实现过程针对可重复读隔离级别。

#### SELECT

当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。

多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。

把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。

除了上面的要求，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。

#### INSERT

将当前系统版本号作为数据行快照的创建版本号。

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/database/master/images/database/mvcc_insert.png"/>
</div>

#### DELETE

将当前系统版本号作为数据行快照的删除版本号。

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/database/master/images/database/mvcc_delete.png"/>
</div>

#### UPDATE

将当前系统版本号作为更新后的数据行快照的创建版本号，同时将当前系统版本号作为更新前的数据行快照的删除版本号。可以理解为先执行 DELETE 后执行 INSERT。

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/database/master/images/database/mvcc_update.png"/>
</div>

### 4.4. 快照读与当前读

#### 快照读

使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。

```sql
select * from table ...;
```

#### 当前读

读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。

```sql
select * from table where ? lock in share mode;
select * from table where ? for update;
insert;
update;
delete;
```

## 5. 分库分表

### 5.1. 水平拆分

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/Database/master/images/database/数据库水平拆分.jpg" width="500" />
</div>

水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。

当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

### 5.2. 垂直拆分

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/Database/master/images/database/数据库垂直拆分.jpg" width="500" />
</div>

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库 payDB、用户数据库 userBD 等。

### 5.3. Sharding 策略

- 哈希取模：hash(key) % NUM_DB
- 范围：可以是 ID 范围也可以是时间范围
- 映射表：使用单独的一个数据库来存储映射关系

### 5.4. Sharding 存在的问题及解决方案

#### 事务问题

使用分布式事务来解决，比如 XA 接口。

#### 跨节点 Join 的问题

可以将原来的 JOIN 查询分解成多个单表查询，然后在用户程序中进行 JOIN。

解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的 id，根据这些 id 发起第二次请求得到关联数据。

#### 跨节点的 count,order by,group by 以及聚合函数问题

这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。

解决方案：与解决跨节点 join 问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和 join 不同的是每个节点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。

#### ID 唯一性

一旦数据库被切分到多个物理节点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的 ID 无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得 ID，以便进行 SQL 路由。

一些常见的主键生成策略：

- 使用全局唯一 ID：GUID。
- 为每个分片指定一个 ID 范围。
- 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)。

#### 数据迁移，容量规划，扩容等问题

来自淘宝综合业务平台团队，它利用对 2 的倍数取余具有向前兼容的特性（如对 4 取余得 1 的数对 2 取余也是 1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了 Sharding 扩容的难度。

更多内容请参考：

- [How Sharding Works](https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6)
- [大众点评订单系统分库分表实践](https://tech.meituan.com/dianping_order_db_sharding.html)

#### 分库数量

分库数量首先和单库能处理的记录数有关，一般来说，Mysql 单库超过 5000 万条记录，Oracle 单库超过 1 亿条记录，DB 压力就很大(当然处理能力和字段数量/访问模式/记录长度有进一步关系)。

## 6. 关系数据库设计理论

### 6.1. 函数依赖

记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖；

对于 A->B，B->C，则 A->C 是一个传递依赖。

### 6.2. 异常

以下的学生课程关系的函数依赖为 Sno, Cname -> Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。

| Sno | Sname  | Sdept  | Mname  | Cname  | Grade |
| :-: | :----: | :----: | :----: | :----: | :---: |
|  1  | 学生-1 | 学院-1 | 院长-1 | 课程-1 |  90   |
|  2  | 学生-2 | 学院-2 | 院长-2 | 课程-2 |  80   |
|  2  | 学生-2 | 学院-2 | 院长-2 | 课程-1 |  100  |
|  3  | 学生-3 | 学院-2 | 院长-2 | 课程-2 |  95   |

不符合范式的关系，会产生很多异常，主要有以下四种异常：

- 冗余数据：例如 学生-2 出现了两次。
- 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
- 删除异常：删除一个信息，那么也会丢失其它信息。例如如果删除了 课程-1，需要删除第一行和第三行，那么 学生-1 的信息就会丢失。
- 插入异常，例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。

### 6.3. 范式

范式理论是为了解决以上提到四种异常。

高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。

<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/database/master/images/database/数据库范式.png"/>
</div>

#### 第一范式 (1NF)

属性不可分；

#### 第二范式 (2NF)

每个非主属性完全函数依赖于键码。

可以通过分解来满足。

<font size=4> **分解前** </font><br>

| Sno | Sname  | Sdept  | Mname  | Cname  | Grade |
| :-: | :----: | :----: | :----: | :----: | :---: |
|  1  | 学生-1 | 学院-1 | 院长-1 | 课程-1 |  90   |
|  2  | 学生-2 | 学院-2 | 院长-2 | 课程-2 |  80   |
|  2  | 学生-2 | 学院-2 | 院长-2 | 课程-1 |  100  |
|  3  | 学生-3 | 学院-2 | 院长-2 | 课程-2 |  95   |

以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：

- Sno -> Sname, Sdept
- Sdept -> Mname
- Sno, Cname-> Grade

Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。

Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。

<font size=4> **分解后** </font><br>

关系-1

| Sno | Sname  | Sdept  | Mname  |
| :-: | :----: | :----: | :----: |
|  1  | 学生-1 | 学院-1 | 院长-1 |
|  2  | 学生-2 | 学院-2 | 院长-2 |
|  3  | 学生-3 | 学院-2 | 院长-2 |

有以下函数依赖：

- Sno -> Sname, Sdept, Mname
- Sdept -> Mname

关系-2

| Sno | Cname  | Grade |
| :-: | :----: | :---: |
|  1  | 课程-1 |  90   |
|  2  | 课程-2 |  80   |
|  2  | 课程-1 |  100  |
|  3  | 课程-2 |  95   |

有以下函数依赖：

- Sno, Cname -> Grade

#### 第三范式 (3NF)

非主属性不传递依赖于键码。

上面的 关系-1 中存在以下传递依赖：Sno -> Sdept -> Mname，可以进行以下分解：

关系-11

| Sno | Sname  | Sdept  |
| :-: | :----: | :----: |
|  1  | 学生-1 | 学院-1 |
|  2  | 学生-2 | 学院-2 |
|  3  | 学生-3 | 学院-2 |

关系-12

| Sdept  | Mname  |
| :----: | :----: |
| 学院-1 | 院长-1 |
| 学院-2 | 院长-2 |

## 7. ER 图

Entity-Relationship，有三个组成部分：实体、属性、联系。

用来进行关系型数据库系统的概念设计。

### 7.1. 实体的三种联系

包含一对一，一对多，多对多三种。

如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；如果是一对一，画两个带箭头的线段；如果是多对多，画两个不带箭头的线段。下图的 Course 和 Student 是一对多的关系。

### 7.2. 表示出现多次的关系

一个实体在联系出现几次，就要用几条线连接。下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。

### 7.3. 联系的多向性

虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。

一般只使用二元联系，可以把多元关系转换为二元关系。

### 7.4. 表示子类

用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。

## 8. 资料

- [数据库系统原理](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/数据库系统原理.md)
